name: Check for Module Update and Apply

on:
  schedule:
    - cron: '30 5 * * *'  # Run daily at 5:30 AM UTC
  workflow_dispatch:  # Keep manual trigger option

env:
  TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
  TF_WORKSPACE_NAME: ${{ secrets.TF_WORKSPACE_NAME }}
  AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
  AZURE_VM_NAME: ${{ secrets.AZURE_VM_NAME }}
  MODULE_REPO: RCFromCLE/terraform-azurerm-jmusicbot

jobs:
  check-and-apply:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        with:
          token: ${{ secrets.PAT_TOKEN }}

      - name: Check for new module release
        id: check_release
        run: |
          module_latest_release=$(curl -s https://api.github.com/repos/${{ env.MODULE_REPO }}/releases/latest | jq -r .tag_name)
          echo "Latest module release: $module_latest_release"
          current_version=$(grep 'version = ' main.tf | sed 's/.*version = "\(.*\)".*/\1/')
          echo "Current version: $current_version"
          if [ "$module_latest_release" != "$current_version" ]; then
            echo "new_release=true" >> $GITHUB_OUTPUT
            echo "latest_version=$module_latest_release" >> $GITHUB_OUTPUT
          else
            echo "new_release=false" >> $GITHUB_OUTPUT
            echo "No new release found. Exiting workflow."
          fi

      - name: Update main.tf
        if: steps.check_release.outputs.new_release == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          sed -i 's/version = "[0-9.]*"/version = "${{ steps.check_release.outputs.latest_version }}"/' main.tf
          git config user.name github-actions
          git config user.email github-actions@github.com
          git add main.tf
          git commit -m "Update module version to ${{ steps.check_release.outputs.latest_version }}" || echo "No changes to commit."
          git push https://RCFromCLE:${{ secrets.PAT_TOKEN }}@github.com/RCFromCLE/terraform-azurerm-jmusicbot-config.git || echo "No changes to push."

      - name: Check for new JMusicBot jar file
        id: check_jar
        run: |
          jar_latest_release=$(curl -s https://api.github.com/repos/jagrosh/MusicBot/releases/latest | jq -r .tag_name)
          echo "Latest JMusicBot jar release: $jar_latest_release"
          new_jar_path="JMusicBot-${jar_latest_release}.jar"
          echo "new_jar_path=$new_jar_path" >> $GITHUB_OUTPUT

      - name: Update variables.tf
        if: steps.check_jar.outputs.new_jar_path != 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          sed -i 's/default\s*=\s*"JMusicBot-.*\.jar"/default = "'${{ steps.check_jar.outputs.new_jar_path }}'"/' variables.tf
          git add variables.tf
          git commit -m "Update jar_path in variables.tf to ${{ steps.check_jar.outputs.new_jar_path }}" || echo "No changes to commit."
          git push https://RCFromCLE:${{ secrets.PAT_TOKEN }}@github.com/RCFromCLE/terraform-azurerm-jmusicbot-config.git || echo "No changes to push."

      - name: Exit if no new release found (scheduled run)
        if: steps.check_release.outputs.new_release == 'false' && github.event_name == 'schedule'
        run: |
          echo "No new release found. Exiting workflow."
          exit 0

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Check Initial VM Power State
        id: check_initial_state
        run: |
          echo "Checking initial VM power state..."
          VM_STATE=$(az vm get-instance-view \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$AZURE_VM_NAME" \
            --query instanceView.statuses[1].displayStatus \
            -o tsv)
          echo "Initial VM Power State: $VM_STATE"
          echo "initial_state=$VM_STATE" >> $GITHUB_OUTPUT

          if [ "$VM_STATE" != "VM running" ]; then
            echo "Starting VM..."
            az vm start --resource-group "$AZURE_RESOURCE_GROUP" --name "$AZURE_VM_NAME"
            echo "Waiting for VM to be in running state..."
            while [ "$VM_STATE" != "VM running" ]; do
              sleep 30
              VM_STATE=$(az vm get-instance-view \
                --resource-group "$AZURE_RESOURCE_GROUP" \
                --name "$AZURE_VM_NAME" \
                --query instanceView.statuses[1].displayStatus \
                -o tsv)
              echo "Current VM state: $VM_STATE"
            done
            echo "VM is now running."
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Initialize Terraform
        run: terraform init

      - name: Apply Terraform Configuration
        run: |
          echo "Running terraform apply..."
          terraform apply -auto-approve
        env:
          TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
          TF_VAR_azure_subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          TF_VAR_azure_client_id: ${{ secrets.AZURE_CLIENT_ID }}
          TF_VAR_azure_client_secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          TF_VAR_azure_tenant_id: ${{ secrets.AZURE_TENANT_ID }}

      - name: Restore Initial VM Power State
        if: steps.check_initial_state.outputs.initial_state != 'VM running'
        run: |
          echo "Restoring VM to initial power state (powering off)..."
          az vm deallocate --resource-group "$AZURE_RESOURCE_GROUP" --name "$AZURE_VM_NAME"
          echo "VM powered off."
